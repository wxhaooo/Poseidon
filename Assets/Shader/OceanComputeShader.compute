// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CalculateGaussianNoise
#pragma kernel UpdateHeightSpectrum
#pragma kernel HorizontalFFT
#pragma kernel VerticalFFT
#pragma kernel CalculateDisplacementField
#pragma kernel UpdateHorizontalSpectrum

// #pragma kernel CorrectSignPhase0
// #pragma kernel CorrectSignPhase1
// #pragma kernel CorrectSignPhase2

#include "Assets/Shader/NoiseHelper.cginc"
#include "Assets/Shader/StatisticalOceanModel.cginc"

int N;
float A;
int spreadingModelType;
float L;
float windDirRadian;
float windSpeed;
float dirDepend;
float time;
float4 windAndSeed;

RWTexture2D<float2> GaussianNoiseTexture;

RWTexture2D<float2> HeightSpectrumTexture;
RWTexture2D<float2> HorizontalSpectrumTexture0;
RWTexture2D<float2> HorizontalSpectrumTexture1;

[numthreads(32,32,1)]
void CalculateGaussianNoise(uint3 threadId:SV_DispatchThreadID)
{
    float2 noise = GaussianNoise_BoxMullerMethod(threadId.xy, N);
    GaussianNoiseTexture[threadId.xy] = noise;
}

[numthreads(32,32,1)]
void UpdateHeightSpectrum(uint3 threadId:SV_DispatchThreadID)
{
    float2 noise = GaussianNoiseTexture[threadId.xy];

    float tIdx = threadId.x;
    float tIdy = threadId.y;

    // float n = tIdx - N / 2.0f;
    // float m = tIdy - N / 2.0f;

    // float kx = 2.0f * PI * n / L;
    // float ky = 2.0f * PI * m / L;

    // L == domainSize
    // float n = tidX / rtSize.x * domainSize - domainSize / 2.0f;
    // float m = tidY / rtSize.y  * domainSize - domainSize / 2.0f;
	
    // float kx = (2.0f * PI * n) / domainSize;
    // float ky = (2.0f * PI * m) / domainSize;

    float kx = (2.0f * PI * tIdx / N) - PI;
    float ky = (2.0f * PI * tIdy / N) - PI;
    float2 k = float2(kx,ky);
    float2 heightSpectrum = CalHeightSpectrum(spreadingModelType, k, noise, windSpeed,A,windDirRadian,dirDepend,time,windAndSeed);
    HeightSpectrumTexture[threadId.xy] = heightSpectrum;
}

[numthreads(32,32,1)]
void UpdateHorizontalSpectrum(uint3 threadId:SV_DispatchThreadID)
{
	float tIdx = threadId.x;
	float tIdy = threadId.y;

	float kx = (2.0f * PI * tIdx / N) - PI;
	float ky = (2.0f * PI * tIdy / N) - PI;

	float2 k = float2(kx,ky);
	k /= max(0.001f, length(k));
	
	float2 hTilde = HeightSpectrumTexture[threadId.xy];
	float2 horizontalSpectrum0 = ComplexMultiply(float2(0.0f,-k.x),hTilde);
	float2 horizontalSpectrum1 = ComplexMultiply(float2(0.0f,-k.y),hTilde);

	HorizontalSpectrumTexture0[threadId.xy] = horizontalSpectrum0;
	HorizontalSpectrumTexture1[threadId.xy] = horizontalSpectrum1;
}

// FFT
int Ns;

RWTexture2D<float2> fftIn;
RWTexture2D<float2> fftOut;

// threadId is index of butterfly
[numthreads(32,32,1)]
void HorizontalFFT(uint3 threadId:SV_DispatchThreadID)
{
	int2 iLeftIndex = threadId.xy;
	int2 iRightIndex = int2(iLeftIndex.x + N * 0.5f,threadId.y);

	int k = threadId.x & (Ns - 1);
	
	int2 oLeftIndex = int2((threadId.x << 1) - k,threadId.y);
	int2 oRightIndex = int2(oLeftIndex.x + Ns,threadId.y);

	float theta = float(k) / Ns * PI;

	float2 f0 = fftIn[iLeftIndex];
	float2 f1 = ComplexMultiply(fftIn[iRightIndex],ExpTheta(theta));

	fftOut[oLeftIndex] = f0 + f1;
	fftOut[oRightIndex] = f0 - f1;
}

[numthreads(32,32,1)]
void VerticalFFT(uint3 threadId:SV_DispatchThreadID)
{
	int2 iLeftIndex = threadId.xy;
	int2 iRightIndex = int2(threadId.x,iLeftIndex.y + N * 0.5f);	

	int k = threadId.y & (Ns - 1);
	
	int2 oLeftIndex = int2(threadId.x,(threadId.y << 1) - k);
	int2 oRightIndex = int2(threadId.x,oLeftIndex.y + Ns);

	float theta = float(k) / Ns * PI;

	float2 f0 = fftIn[iLeftIndex];
	float2 f1 = ComplexMultiply(fftIn[iRightIndex],ExpTheta(theta));

	fftOut[oLeftIndex] = f0 + f1;
	fftOut[oRightIndex] = f0 - f1;
}

// another fft form https://zhuanlan.zhihu.com/p/96811613 
// threadId is index of butterfly
// [numthreads(32,32,1)]
// void HorizontalFFT(uint3 threadId:SV_DispatchThreadID)
// {
// 	// 一开始Ns2是int，精度不够，在shader里面尽量用float吧
// 	float Ns2 = Ns * 2.0f;
// 	int2 iLeftIndex = int2(floor(threadId.x / Ns2) * Ns + threadId.x % Ns, threadId.y);
// 	int2 iRightIndex = int2(iLeftIndex.x + N * 0.5f, iLeftIndex.y);	
//
// 	float theta = 2.0f * PI * (threadId.x / Ns2);
// 	
// 	float2 f0 = fftIn[iLeftIndex];
// 	float2 f1 = ComplexMultiply(fftIn[iRightIndex],ExpTheta(theta));
//
// 	fftOut[threadId.xy] = f0 + f1;
// }
//
// [numthreads(32,32,1)]
// void VerticalFFT(uint3 threadId:SV_DispatchThreadID)
// {
// 	// 一开始Ns2是int，精度不够，在shader里面尽量用float吧
// 	float Ns2 = Ns * 2.0f;
// 	int2 iLeftIndex = int2(threadId.x,floor(threadId.y / Ns2) * Ns + threadId.y % Ns);
// 	int2 iRightIndex = int2(iLeftIndex.x, iLeftIndex.y + N * 0.5f);
//
// 	float theta = 2.0f * PI * (threadId.y / Ns2);
// 	
// 	float2 f0 = fftIn[iLeftIndex];
// 	float2 f1 = ComplexMultiply(fftIn[iRightIndex],ExpTheta(theta));
//
// 	fftOut[threadId.xy] = f0 + f1;
// }

// // threadId is index of butterfly
// [numthreads(32,32,1)]
// void CorrectSignPhase0(uint3 threadId:SV_DispatchThreadID)
// {
// 	float2 input = fftIn[threadId.xy];
// 	// pow(-1,threadId.x)
// 	fftOut[threadId.xy] = input * RealPow(-1,threadId.x);
// }
//
// // threadId is index of butterfly
// [numthreads(32,32,1)]
// void CorrectSignPhase1(uint3 threadId:SV_DispatchThreadID)
// {
// 	fftOut[threadId.xy] = fftIn[threadId.xy] * RealPow(-1,threadId.y + threadId.x - N / 2);
// }
//
// // threadId is index of butterfly
// [numthreads(32,32,1)]
// void CorrectSignPhase2(uint3 threadId:SV_DispatchThreadID)
// {
// 	float2 tmp = fftIn[threadId.xy] * RealPow(-1,threadId.y - N / 2);
// 	fftOut[threadId.xy] = tmp;
// }

// scale
float heightScale;
float horizontalScale;

RWTexture2D<float2> heightField;
RWTexture2D<float2> horizontalField0;
RWTexture2D<float2> horizontalField1;
RWTexture2D<float4> displacementField;

[numthreads(32,32,1)]
void CalculateDisplacementField(uint3 threadId:SV_DispatchThreadID)
{
	float x = length(horizontalField0[threadId.xy]) / (N * N) * horizontalScale;
	float y = length(heightField[threadId.xy]) / (N * N) * heightScale;
	float z = length(horizontalField1[threadId.xy]) / (N * N) * horizontalScale;
	
	displacementField[threadId.xy] = float4(x,y,z,1.0f);
}
